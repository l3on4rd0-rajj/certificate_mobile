-----BEGIN CERTIFICATE-----
MIIDpzCCAo+gAwIBAgIEX1BRBzANBgkqhkiG9w0BAQsFADCBijEUMBIGA1UEBhML
UG9ydFN3aWdnZXIxFDASBgNVBAgTC1BvcnRTd2lnZ2VyMRQwEgYDVQQHEwtQb3J0
U3dpZ2dlcjEUMBIGA1UEChMLUG9ydFN3aWdnZXIxFzAVBgNVBAsTDlBvcnRTd2ln
Z2VyIENBMRcwFQYDVQQDEw5Qb3J0U3dpZ2dlciBDQTAeFw0xNDEwMDIwMDU0NTJa
Fw0zNDEwMDIwMDU0NTJaMIGKMRQwEgYDVQQGEwtQb3J0U3dpZ2dlcjEUMBIGA1UE
CBMLUG9ydFN3aWdnZXIxFDASBgNVBAcTC1BvcnRTd2lnZ2VyMRQwEgYDVQQKEwtQ
b3J0U3dpZ2dlcjEXMBUGA1UECxMOUG9ydFN3aWdnZXIgQ0ExFzAVBgNVBAMTDlBv
cnRTd2lnZ2VyIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtOL3
3WKJogGORsTqAWzinbggD+70OrOvZSlL43+nDxyv9vu9vIw2Jm/I8FHaAewXMk+G
hjxU7IvBHEE03rvQUEqsECdH9ABJmtYyKiVJqD+6UAefbzcRSGmE742VQMsGiY6i
zTOAhBPhivIjSOADmDd2ytNX1/Ih8RLuFSX5G1UAkM/cwaaqC+JqW4ZqWi+sjN4I
9r8NotjVpjtKXrzXatUEJ0a1wyOk1hAAnyKscBTVaiq2COI8xELHm+yXoOaDSqZS
Sr4aS7PoztAJytdbsKRKvSQaUyLdf2hvaQ0az6HP3QY4zTP2yXhWS5UZjiqsSmwq
44SIr49NrmSBcS0D/wIDAQABoxMwETAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3
DQEBCwUAA4IBAQCg0uYL15fEHg5nez+5g7jYvDXpNwDvrWm3nUOm+1X9fe3VAG1f
l+r8asVDX6Rx/X6SrL0Z+Wm1SMWT4fmrZshIO6y+XA7ugG4rSFdK9AaLHypQkNSQ
6wOLE827uFE4EKuWtFbumI5JvuX7P4f7yZ1vLvuhW/Xov/LHcxvfi3jdeKhqn2a/
EC59aTDkm/kH8mtFal6vlcWaOnPmgrs5cQ7pKWt427sS4F7uCdcjmmSDNFwDsjOT
SzXNakPRBACerfOR9qS2vqQkTtsAlaZT7m9AmecVgFEhC99OOBCPGqPKCQvDBHQ7
ufi92+G+18vaVWLglFDM05bNStSVZZHxwXIF
-----END CERTIFICATE-----

import pandas as pd
import argparse


def process_vulnerabilities(input_file, output_file):
    # Lê o arquivo CSV com normalização dos nomes das colunas
    try:
        df = pd.read_csv(input_file, delimiter=None)  # Auto-detecta delimitadores
        df.columns = df.columns.str.strip().str.lower()  # Remove espaços e converte para minúsculas
    except Exception as e:
        print(f"Erro ao ler o arquivo CSV: {e}")
        return

    # Nomes esperados das colunas (em minúsculas)
    expected_columns = {'issuename', 'friority', 'projectversionid'}

    # Verifica se as colunas estão presentes
    if not expected_columns.issubset(df.columns):
        print(f"Colunas encontradas no arquivo: {list(df.columns)}")
        print(f"O arquivo CSV deve conter as colunas: {expected_columns}")
        return

    # Agrupa os dados por projectVersionID e friority
    try:
        summary = (
            df.groupby(['projectversionid', 'friority'])
            .size()
            .unstack(fill_value=0)
            .reset_index()
        )
    except Exception as e:
        print(f"Erro ao agrupar os dados: {e}")
        return

    # Exporta o resumo para o arquivo de saída
    try:
        summary.to_csv(output_file, index=False)
        print(f"Resumo gerado com sucesso em: {output_file}")
    except Exception as e:
        print(f"Erro ao salvar o arquivo de saída: {e}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Processa um arquivo CSV de vulnerabilidades.")
    parser.add_argument(
        "input_file",
        help="Caminho para o arquivo CSV de entrada (ex.: full_vulnerabilities_report.csv)"
    )
    parser.add_argument(
        "output_file",
        help="Caminho para o arquivo CSV de saída (ex.: vulnerabilities_summary.csv)"
    )

    args = parser.parse_args()

    # Executa o processamento
    process_vulnerabilities(args.input_file, args.output_file)


    # Parseia os argumentos
    args = parser.parse_args()

    # Executa o processamento
    process_vulnerabilities(args.input_file, args.output_file)
