-----BEGIN CERTIFICATE-----
MIIDpzCCAo+gAwIBAgIEX1BRBzANBgkqhkiG9w0BAQsFADCBijEUMBIGA1UEBhML
UG9ydFN3aWdnZXIxFDASBgNVBAgTC1BvcnRTd2lnZ2VyMRQwEgYDVQQHEwtQb3J0
U3dpZ2dlcjEUMBIGA1UEChMLUG9ydFN3aWdnZXIxFzAVBgNVBAsTDlBvcnRTd2ln
Z2VyIENBMRcwFQYDVQQDEw5Qb3J0U3dpZ2dlciBDQTAeFw0xNDEwMDIwMDU0NTJa
Fw0zNDEwMDIwMDU0NTJaMIGKMRQwEgYDVQQGEwtQb3J0U3dpZ2dlcjEUMBIGA1UE
CBMLUG9ydFN3aWdnZXIxFDASBgNVBAcTC1BvcnRTd2lnZ2VyMRQwEgYDVQQKEwtQ
b3J0U3dpZ2dlcjEXMBUGA1UECxMOUG9ydFN3aWdnZXIgQ0ExFzAVBgNVBAMTDlBv
cnRTd2lnZ2VyIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtOL3
3WKJogGORsTqAWzinbggD+70OrOvZSlL43+nDxyv9vu9vIw2Jm/I8FHaAewXMk+G
hjxU7IvBHEE03rvQUEqsECdH9ABJmtYyKiVJqD+6UAefbzcRSGmE742VQMsGiY6i
zTOAhBPhivIjSOADmDd2ytNX1/Ih8RLuFSX5G1UAkM/cwaaqC+JqW4ZqWi+sjN4I
9r8NotjVpjtKXrzXatUEJ0a1wyOk1hAAnyKscBTVaiq2COI8xELHm+yXoOaDSqZS
Sr4aS7PoztAJytdbsKRKvSQaUyLdf2hvaQ0az6HP3QY4zTP2yXhWS5UZjiqsSmwq
44SIr49NrmSBcS0D/wIDAQABoxMwETAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3
DQEBCwUAA4IBAQCg0uYL15fEHg5nez+5g7jYvDXpNwDvrWm3nUOm+1X9fe3VAG1f
l+r8asVDX6Rx/X6SrL0Z+Wm1SMWT4fmrZshIO6y+XA7ugG4rSFdK9AaLHypQkNSQ
6wOLE827uFE4EKuWtFbumI5JvuX7P4f7yZ1vLvuhW/Xov/LHcxvfi3jdeKhqn2a/
EC59aTDkm/kH8mtFal6vlcWaOnPmgrs5cQ7pKWt427sS4F7uCdcjmmSDNFwDsjOT
SzXNakPRBACerfOR9qS2vqQkTtsAlaZT7m9AmecVgFEhC99OOBCPGqPKCQvDBHQ7
ufi92+G+18vaVWLglFDM05bNStSVZZHxwXIF
-----END CERTIFICATE-----

import json
import streamlit as st
import requests
import pandas as pd
import plotly.express as px


# Função para carregar a coleção Postman de um arquivo enviado
def load_collection(uploaded_file):
    try:
        return json.load(uploaded_file)
    except json.JSONDecodeError:
        st.error("Erro: O arquivo enviado não é um JSON válido.")
        return None


# Função para realizar requisições com base em informações do endpoint
def fetch_data_from_collection(endpoint_info, base_url, auth_token=None):
    # Constrói a URL completa
    url = f"{base_url.rstrip('/')}/{endpoint_info['url']['path'].lstrip('/')}"
    method = endpoint_info['method']
    headers = {header['key']: header['value'] for header in endpoint_info.get('header', [])}

    # Adiciona o token de autenticação, se fornecido
    if auth_token:
        headers["Authorization"] = f"Bearer {auth_token}"

    try:
        # Verifica o método HTTP
        if method == "GET":
            response = requests.get(url, headers=headers)
        elif method == "POST":
            body = endpoint_info.get('body', {}).get('raw', "{}")
            response = requests.post(url, headers=headers, json=json.loads(body))
        else:
            st.error(f"Método {method} não suportado.")
            return None

        # Trata o retorno da API
        if response.status_code in (200, 201):
            return response.json()
        else:
            st.error(f"Erro {response.status_code}: {response.text}")
            return None

    except Exception as e:
        st.error(f"Erro ao realizar a requisição: {e}")
        return None


# Função para processar e exibir dados
def display_data(data, endpoint_name):
    st.header(f"Resultados - {endpoint_name}")
    st.json(data)

    # Tenta converter os dados para um DataFrame e exibir
    if isinstance(data, list):
        try:
            df = pd.DataFrame(data)
            st.dataframe(df)

            # Exibe um gráfico básico, se houver a coluna 'severity'
            if "severity" in df.columns:
                fig = px.bar(df, x="severity", title="Vulnerabilidades por Severidade")
                st.plotly_chart(fig)
        except Exception as e:
            st.error(f"Erro ao exibir dados como tabela: {e}")
    elif isinstance(data, dict):
        st.write("Os dados retornados estão no formato de dicionário.")
    else:
        st.error("Formato de dados inesperado. Não foi possível processar.")


# Função principal do Streamlit
def main():
    st.title("Painel de Consumo de API - Baseado em Coleção Postman")

    # Upload de arquivo
    uploaded_file = st.file_uploader("Faça upload da coleção Postman (JSON)", type=["json", "txt"])
    
    if uploaded_file:
        collection = load_collection(uploaded_file)

        if collection:
            st.sidebar.header("Endpoints Disponíveis")
            endpoints = [
                {"name": item["name"], "info": item["request"]}
                for item in collection.get("item", [])
                if "request" in item
            ]

            # Verifica se há endpoints na coleção
            if not endpoints:
                st.error("Nenhum endpoint válido foi encontrado na coleção.")
                return

            # Seleção de endpoint
            selected_endpoint = st.sidebar.selectbox(
                "Escolha um Endpoint",
                options=[endpoint["name"] for endpoint in endpoints]
            )
            selected_endpoint_info = next(
                ep for ep in endpoints if ep["name"] == selected_endpoint
            )

            # Inputs do usuário
            base_url = st.text_input("Base URL", value="https://seu-endpoint-base")
            auth_token = st.text_input("Token de Autenticação (opcional)", type="password")

            # Botão para buscar dados
            if st.button("Buscar Dados"):
                data = fetch_data_from_collection(selected_endpoint_info["info"], base_url, auth_token)
                if data:
                    display_data(data, selected_endpoint)


# Executa o aplicativo Streamlit
if __name__ == "__main__":
    main()
