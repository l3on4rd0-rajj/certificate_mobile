#!/bin/bash

# Script refatorado para testar honeypots com implementação Netcat para MySQL
# Objetivo: Verificar geração e coleta de logs no Splunk

## Configurações Globais
readonly LOG_FILE="/tmp/honeypot_test_$(date +%Y%m%d_%H%M%S).log"
readonly HONEYPOTS=("192.168.1.100" "192.168.1.101" "192.168.1.102")
readonly SSH_USER="root"
readonly RDP_USER="Administrator"
readonly MYSQL_HANDSHAKE="\x00\x00\x00\x0a\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"

## Funções Auxiliares

# Registrar atividades com timestamp
log() {
    local message="$1"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ${message}" | tee -a "${LOG_FILE}"
}

# Verificar dependências essenciais
verify_dependencies() {
    local required=("nmap" "nc" "ssh" "curl")
    local missing=()
    
    for cmd in "${required[@]}"; do
        if ! command -v "${cmd}" >/dev/null 2>&1; then
            missing+=("${cmd}")
        fi
    done

    if [ ${#missing[@]} -gt 0 ]; then
        log "ERRO: Dependências ausentes: ${missing[*]}"
        log "Instale com: sudo apt install ${missing[*]}"
        exit 1
    fi
}

## Funções de Teste

# Teste de conexão SSH seguro
test_ssh_connection() {
    local host="$1"
    log "Iniciando teste SSH em ${host}"
    
    # Tentativa de conexão básica
    ssh -o BatchMode=yes -o ConnectTimeout=3 -o StrictHostKeyChecking=no "${SSH_USER}@${host}" exit 2>&1 | tee -a "${LOG_FILE}"
    
    # Teste com credenciais inválidas
    local fake_passwords=("invalid_pass" "$(date +%s)" "honeypot_test")
    for pass in "${fake_passwords[@]}"; do
        sshpass -p "${pass}" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=2 "${SSH_USER}@${host}" exit 2>&1 | tee -a "${LOG_FILE}"
        sleep 1
    done
    
    log "Teste SSH concluído para ${host}"
}

# Teste MySQL via Netcat (implementação refatorada)
test_mysql_service() {
    local host="$1"
    log "Iniciando análise MySQL em ${host} via Netcat"
    
    # Verificação básica de porta
    if nc -zv -w 3 "${host}" 3306 2>&1 | tee -a "${LOG_FILE}"; then
        log "Porta MySQL (3306) acessível em ${host}"
        
        # Envio de handshake simulado
        log "Enviando handshake MySQL simulado"
        if echo -e "${MYSQL_HANDSHAKE}" | nc -w 3 "${host}" 3306 | head -c 20 | tee -a "${LOG_FILE}"; then
            log "Resposta do serviço MySQL detectada"
        else
            log "Serviço não respondeu ao handshake"
        fi
    else
        log "Porta MySQL (3306) inacessível em ${host}"
    fi
    
    log "Análise MySQL concluída para ${host}"
}

# Teste RDP otimizado
test_rdp_service() {
    local host="$1"
    log "Testando serviço RDP em ${host}"
    
    if command -v nc >/dev/null; then
        if nc -zv -w 3 "${host}" 3389 2>&1 | tee -a "${LOG_FILE}"; then
            log "Porta RDP (3389) aberta em ${host}"
            # Simulação básica de conexão
            echo -e "\x03\x00\x00\x0b\x06\xe0\x00\x00\x00\x00\x00" | nc -w 2 "${host}" 3389 | head -c 10 | tee -a "${LOG_FILE}"
        else
            log "Porta RDP (3389) fechada em ${host}"
        fi
    fi
    
    log "Teste RDP concluído para ${host}"
}

# Varredura de portas com Nmap
perform_port_scan() {
    local host="$1"
    log "Iniciando varredura Nmap em ${host}"
    
    # Scan rápido de portas essenciais
    nmap -T3 --max-retries 1 --max-rtt-timeout 500ms -p 21,22,80,443,3389,3306 "${host}" 2>&1 | tee -a "${LOG_FILE}"
    
    log "Varredura Nmap concluída para ${host}"
}

# Testes genéricos de rede
test_network_services() {
    local host="$1"
    log "Iniciando testes genéricos em ${host}"
    
    # Teste de portas comuns
    local common_ports=(21 22 80 443 8080 3389 3306)
    for port in "${common_ports[@]}"; do
        timeout 2 bash -c "echo > /dev/tcp/${host}/${port}" 2>&1 | tee -a "${LOG_FILE}"
    done
    
    # Testes HTTP/S básicos
    curl -sI --connect-timeout 3 "http://${host}" 2>&1 | tee -a "${LOG_FILE}"
    curl -sIk --connect-timeout 3 "https://${host}" 2>&1 | tee -a "${LOG_FILE}"
    
    log "Testes genéricos concluídos para ${host}"
}

## Execução Principal

main() {
    verify_dependencies
    log "Início dos testes de honeypot"
    
    for target in "${HONEYPOTS[@]}"; do
        log "Iniciando testes no host: ${target}"
        
        test_ssh_connection "${target}"
        test_mysql_service "${target}"
        test_rdp_service "${target}"
        perform_port_scan "${target}"
        test_network_services "${target}"
        
        log "Testes concluídos para ${target}"
        sleep $((RANDOM % 4 + 1))  # Intervalo aleatório entre 1-5 segundos
    done
    
    log "Todos os testes foram finalizados"
    log "Arquivo de log disponível em: ${LOG_FILE}"
    log "Verifique os logs no Splunk para validação"
}

main


---------------------------------------------------------------------------

<#
.SYNOPSIS
Script para testar honeypots simulando atividades maliciosas no Windows
Objetivo: Verificar se os logs estão sendo gerados e coletados pelo Splunk
#>

# Configurações
$LOG_FILE = "C:\temp\honeypot_test_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
$HONEYPOTS = @("192.168.1.100", "192.168.1.101", "192.168.1.102")  # Substitua pelos IPs dos seus honeypots
$SSH_USER = "root"
$MYSQL_USER = "admin"
$RDP_USER = "Administrator"

# Função para registrar atividades
function Log {
    param (
        [string]$message
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] $message"
    Write-Output $logEntry | Out-File -FilePath $LOG_FILE -Append
    Write-Output $logEntry
}

# Verificar dependências
function Check-Dependencies {
    # Verificar se o Nmap está instalado (opcional)
    if (-not (Get-Command nmap -ErrorAction SilentlyContinue)) {
        Log "AVISO: Nmap não encontrado. Considere instalar para testes mais completos."
    }
    
    # Verificar se o Putty/Plink está instalado para SSH
    if (-not (Get-Command plink -ErrorAction SilentlyContinue)) {
        Log "AVISO: Plink (Putty) não encontrado. Testes SSH limitados."
    }
}

# Teste de conexão SSH
function Test-SSH {
    param (
        [string]$host
    )
    Log "Iniciando teste SSH em $host"
    
    # Tentativa de conexão básica (requer Plink/Putty)
    if (Get-Command plink -ErrorAction SilentlyContinue) {
        try {
            $output = plink -ssh "$SSH_USER@$host" -pw "wrongpassword" -batch -no-antispoof exit 2>&1
            Log $output
        } catch {
            Log "Erro SSH: $_"
        }
    } else {
        # Alternativa usando .NET (mais limitada)
        try {
            $sshClient = New-Object System.Net.Sockets.TcpClient($host, 22)
            Log "Conexão TCP/22 estabelecida com $host"
            $sshClient.Close()
        } catch {
            Log "Falha ao conectar em SSH ($host): $_"
        }
    }
    
    Log "Teste SSH concluído para $host"
}

# Teste de conexão MySQL
function Test-MySQL {
    param (
        [string]$host
    )
    Log "Iniciando teste MySQL em $host"
    
    # Requer MySQL Client instalado ou módulo MySql.Data
    try {
        # Tentativa básica de conexão (se o módulo MySQL estiver disponível)
        if (Get-Module -Name MySql.Data -ListAvailable) {
            Add-Type -Path "C:\Program Files (x86)\MySQL\MySQL Connector Net 8.0.XX\Assemblies\v4.5.2\MySql.Data.dll"
            $connStr = "server=$host;uid=$MYSQL_USER;pwd=wrongpassword;database=mysql;Connect Timeout=5"
            $conn = New-Object MySql.Data.MySqlClient.MySqlConnection($connStr)
            $conn.Open()
            Log "Conexão MySQL bem-sucedida (não esperado)"
            $conn.Close()
        } else {
            # Alternativa usando telnet/netcat para testar a porta
            Test-NetConnection -ComputerName $host -Port 3306 -InformationLevel Quiet
            if ($?) {
                Log "Porta MySQL (3306) aberta em $host"
            } else {
                Log "Falha ao conectar na porta MySQL (3306)"
            }
        }
    } catch {
        Log "Erro MySQL: $_"
    }
    
    Log "Teste MySQL concluído para $host"
}

# Teste de conexão RDP
function Test-RDP {
    param (
        [string]$host
    )
    Log "Iniciando teste RDP em $host"
    
    # Testar se a porta RDP está aberta
    try {
        $rdpTest = Test-NetConnection -ComputerName $host -Port 3389 -InformationLevel Detailed
        if ($rdpTest.TcpTestSucceeded) {
            Log "Porta RDP (3389) aberta em $host"
            
            # Tentativa de conexão RDP (simulada)
            Log "Simulando tentativa RDP com credenciais inválidas"
            # Nota: Não podemos realmente autenticar programaticamente sem ferramentas adicionais
        } else {
            Log "Porta RDP (3389) fechada em $host"
        }
    } catch {
        Log "Erro ao testar RDP: $_"
    }
    
    Log "Teste RDP concluído para $host"
}

# Teste de port scanning
function Test-PortScan {
    param (
        [string]$host
    )
    Log "Iniciando scan de portas em $host"
    
    # Portas comuns para testar
    $commonPorts = @(21, 22, 23, 80, 443, 3306, 3389, 8080)
    
    foreach ($port in $commonPorts) {
        try {
            $test = Test-NetConnection -ComputerName $host -Port $port -InformationLevel Quiet
            if ($test) {
                Log "Porta $port aberta em $host"
            } else {
                Log "Porta $port fechada em $host"
            }
        } catch {
            Log "Erro ao testar porta $port: $_"
        }
    }
    
    Log "Scan de portas concluído para $host"
}

# Teste de conexões genéricas
function Test-Generic {
    param (
        [string]$host
    )
    Log "Iniciando testes genéricos em $host"
    
    # Teste HTTP/HTTPS básico
    try {
        Log "Testando HTTP em $host"
        $httpResult = Invoke-WebRequest -Uri "http://$host" -TimeoutSec 5 -ErrorAction Stop
        Log "HTTP Response: $($httpResult.StatusCode)"
    } catch {
        Log "HTTP Error: $_"
    }
    
    try {
        Log "Testando HTTPS em $host"
        $httpsResult = Invoke-WebRequest -Uri "https://$host" -TimeoutSec 5 -ErrorAction Stop
        Log "HTTPS Response: $($httpsResult.StatusCode)"
    } catch {
        Log "HTTPS Error: $_"
    }
    
    Log "Testes genéricos concluídos para $host"
}

# Execução principal
function Main {
    Check-Dependencies
    Log "Iniciando testes de honeypot"
    
    foreach ($honeypot in $HONEYPOTS) {
        Log "Testando honeypot: $honeypot"
        Test-SSH -host $honeypot
        Test-MySQL -host $honeypot
        Test-RDP -host $honeypot
        Test-PortScan -host $honeypot
        Test-Generic -host $honeypot
        Log "Testes concluídos para $honeypot"
        Start-Sleep -Seconds 5
    }
    
    Log "Todos os testes foram concluídos"
    Log "Verifique os logs no Splunk para confirmar a coleta"
    Log "Log local salvo em: $LOG_FILE"
}

# Executar o script principal
Main
    log "Verifique os logs no Splunk para confirmar a coleta"
    log "Log local salvo em: $LOG_FILE"
}

main


--------------------------------------------------------------------------------------

#!/bin/bash

# Script para testar honeypots simulando atividades suspeitas (não maliciosas)
# Objetivo: Verificar se os logs estão sendo gerados e coletados pelo Splunk

# Configurações
LOG_FILE="/tmp/honeypot_test_$(date +%Y%m%d_%H%M%S).log"
HONEYPOTS=("192.168.1.100" "192.168.1.101" "192.168.1.102")  # Substitua pelos IPs dos seus honeypots
SSH_USER="root"
MYSQL_USER="admin"
RDP_USER="Administrator"

# Função para registrar atividades
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# Verificar dependências (versão simplificada)
check_dependencies() {
    local deps=("nmap" "nc" "curl" "ssh" "mysql")
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            log "ERRO: $dep não instalado. Instale com: sudo apt install $dep"
            exit 1
        fi
    done
}

# Teste de conexão SSH (versão discreta)
test_ssh() {
    local host=$1
    log "Iniciando teste SSH em $host"
    
    # Tentativas de login discretas
    local passwords=("invalidpass" "$(date +%s)" "testing123")
    
    for pass in "${passwords[@]}"; do
        log "Testando credencial SSH: $SSH_USER/$pass"
        sshpass -p "$pass" ssh -o StrictHostKeyChecking=no \
                -o ConnectTimeout=3 \
                -o PreferredAuthentications=password \
                "$SSH_USER@$host" exit 2>&1 | tee -a "$LOG_FILE"
    done
    
    # Comandos SSH básicos (se conseguir conectar)
    log "Testando comando SSH básico"
    ssh -o BatchMode=yes -o ConnectTimeout=3 "$SSH_USER@$host" "whoami; id" 2>&1 | tee -a "$LOG_FILE"
    
    log "Teste SSH concluído para $host"
}

# Teste de conexão MySQL (versão segura)
test_mysql() {
    local host=$1
    log "Iniciando teste MySQL em $host"
    
    # Tentativas de conexão não intrusivas
    local test_queries=(
        "SELECT version()" 
        "SHOW DATABASES" 
        "SELECT user FROM mysql.user LIMIT 1"
    )
    
    for query in "${test_queries[@]}"; do
        log "Executando query: $query"
        mysql -h "$host" -u "$MYSQL_USER" -p"invalidpassword" -e "$query" 2>&1 | tee -a "$LOG_FILE"
        sleep 1
    done
    
    log "Teste MySQL concluído para $host"
}

# Teste de port scanning (versão otimizada)
test_nmap() {
    local host=$1
    log "Iniciando scan Nmap em $host (modo discreto)"
    
    # Scan rápido e discreto
    nmap -T3 --max-retries 1 --max-rtt-timeout 500ms "$host" 2>&1 | tee -a "$LOG_FILE"
    
    # Verificação apenas de portas específicas
    nmap -T3 -p 21,22,80,443,3389,3306 "$host" 2>&1 | tee -a "$LOG_FILE"
    
    log "Teste Nmap concluído para $host"
}

# Teste de conexões genéricas
test_generic() {
    local host=$1
    log "Iniciando testes genéricos em $host"
    
    # Teste de portas com timeout reduzido
    local ports=(21 22 80 443 3389 3306 8080)
    for port in "${ports[@]}"; do
        log "Testando porta $port"
        timeout 2 bash -c "echo > /dev/tcp/$host/$port" 2>&1 | tee -a "$LOG_FILE"
    done
    
    # Testes HTTP/S
    log "Testando requisições web"
    curl -sSI --connect-timeout 3 "http://$host" 2>&1 | tee -a "$LOG_FILE"
    curl -sSIk --connect-timeout 3 "https://$host" 2>&1 | tee -a "$LOG_FILE"
    
    log "Testes genéricos concluídos para $host"
}

# Execução principal
main() {
    check_dependencies
    log "Iniciando testes de honeypot (modo discreto)"
    
    for honeypot in "${HONEYPOTS[@]}"; do
        log "Testando honeypot: $honeypot"
        test_ssh "$honeypot"
        test_mysql "$honeypot"
        test_nmap "$honeypot"
        test_generic "$honeypot"
        log "Testes concluídos para $honeypot"
        sleep $((RANDOM % 5 + 1))  # Intervalo aleatório entre 1-5 segundos
    done
    
    log "Todos os testes foram concluídos"
    log "Verifique os logs no Splunk para confirmar a coleta"
    log "Log local salvo em: $LOG_FILE"
}

main
