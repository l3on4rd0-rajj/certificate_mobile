#!/bin/bash

# Script para testar honeypots simulando atividades maliciosas
# Objetivo: Verificar se os logs estão sendo gerados e coletados pelo Splunk

# Configurações
LOG_FILE="/tmp/honeypot_test_$(date +%Y%m%d_%H%M%S).log"
HONEYPOTS=("192.168.1.100" "192.168.1.101" "192.168.1.102")  # Substitua pelos IPs dos seus honeypots
SSH_USER="root"
MYSQL_USER="admin"
RDP_USER="Administrator"
WORDLIST="/usr/share/wordlists/rockyou.txt"  # Ajuste para o caminho da sua wordlist

# Função para registrar atividades
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# Verificar dependências
check_dependencies() {
    command -v nmap >/dev/null 2>&1 || { echo >&2 "nmap não instalado. Instale com: sudo apt install nmap"; exit 1; }
    command -v hydra >/dev/null 2>&1 || { echo >&2 "hydra não instalado. Instale com: sudo apt install hydra"; exit 1; }
    command -v nc >/dev/null 2>&1 || { echo >&2 "netcat não instalado. Instale com: sudo apt install netcat"; exit 1; }
}

# Teste de conexão SSH
test_ssh() {
    local host=$1
    log "Iniciando teste SSH em $host"
    
    # Tentativa de conexão simples
    ssh -o BatchMode=yes -o ConnectTimeout=5 -o StrictHostKeyChecking=no "$SSH_USER@$host" exit 2>&1 | tee -a "$LOG_FILE"
    
    # Simulação de brute force (versão simplificada)
    log "Simulando brute force SSH em $host (3 tentativas)"
    for pass in "password" "123456" "admin"; do
        sshpass -p "$pass" ssh -o StrictHostKeyChecking=no "$SSH_USER@$host" exit 2>&1 | tee -a "$LOG_FILE"
    done
    
    log "Teste SSH concluído para $host"
}

# Teste de conexão MySQL
test_mysql() {
    local host=$1
    log "Iniciando teste MySQL em $host"
    
    # Tentativa de conexão simples
    mysql -h "$host" -u "$MYSQL_USER" -p"wrongpassword" -e "exit" 2>&1 | tee -a "$LOG_FILE"
    
    # Tentativa de comandos SQL
    log "Testando injeção SQL básica em $host"
    for cmd in "SELECT version();" "SHOW databases;" "SELECT * FROM information_schema.tables;"; do
        mysql -h "$host" -u "$MYSQL_USER" -p"wrongpassword" -e "$cmd" 2>&1 | tee -a "$LOG_FILE"
    done
    
    log "Teste MySQL concluído para $host"
}

# Teste de conexão RDP
test_rdp() {
    local host=$1
    log "Iniciando teste RDP em $host"
    
    # Tentativa de conexão básica (requer xfreerdp ou rdesktop)
    if command -v xfreerdp >/dev/null 2>&1; then
        xfreerdp /v:"$host" /u:"$RDP_USER" /p:"wrongpassword" +auth-only /sec:nla 2>&1 | tee -a "$LOG_FILE"
    elif command -v rdesktop >/dev/null 2>&1; then
        rdesktop "$host" -u "$RDP_USER" -p "wrongpassword" 2>&1 | tee -a "$LOG_FILE"
    else
        log "Ferramenta RDP não encontrada (xfreerdp ou rdesktop)"
    fi
    
    log "Teste RDP concluído para $host"
}

# Teste de port scanning com Nmap
test_nmap() {
    local host=$1
    log "Iniciando scan Nmap em $host"
    
    # Scan rápido de portas comuns
    nmap -T4 -F "$host" 2>&1 | tee -a "$LOG_FILE"
    
    # Detecção de serviços
    nmap -sV -T4 "$host" -p 21,22,80,443,3389 2>&1 | tee -a "$LOG_FILE"
    
    log "Teste Nmap concluído para $host"
}

# Teste de conexões genéricas
test_generic() {
    local host=$1
    log "Iniciando testes genéricos em $host"
    
    # Tentativa de conexão em várias portas com netcat
    for port in 21 22 23 80 443 8080 3389; do
        log "Testando conexão TCP na porta $port"
        nc -zv -w 2 "$host" "$port" 2>&1 | tee -a "$LOG_FILE"
    done
    
    # Tentativa de HTTP básico
    log "Testando requisição HTTP básica"
    curl -s -I "http://$host" 2>&1 | tee -a "$LOG_FILE"
    curl -s -I "https://$host" 2>&1 | tee -a "$LOG_FILE"
    
    log "Testes genéricos concluídos para $host"
}

# Execução principal
main() {
    check_dependencies
    log "Iniciando testes de honeypot"
    
    for honeypot in "${HONEYPOTS[@]}"; do
        log "Testando honeypot: $honeypot"
        test_ssh "$honeypot"
        test_mysql "$honeypot"
        test_rdp "$honeypot"
        test_nmap "$honeypot"
        test_generic "$honeypot"
        log "Testes concluídos para $honeypot"
        sleep 5
    done
    
    log "Todos os testes foram concluídos"


---------------------------------------------------------------------------

<#
.SYNOPSIS
Script para testar honeypots simulando atividades maliciosas no Windows
Objetivo: Verificar se os logs estão sendo gerados e coletados pelo Splunk
#>

# Configurações
$LOG_FILE = "C:\temp\honeypot_test_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
$HONEYPOTS = @("192.168.1.100", "192.168.1.101", "192.168.1.102")  # Substitua pelos IPs dos seus honeypots
$SSH_USER = "root"
$MYSQL_USER = "admin"
$RDP_USER = "Administrator"

# Função para registrar atividades
function Log {
    param (
        [string]$message
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] $message"
    Write-Output $logEntry | Out-File -FilePath $LOG_FILE -Append
    Write-Output $logEntry
}

# Verificar dependências
function Check-Dependencies {
    # Verificar se o Nmap está instalado (opcional)
    if (-not (Get-Command nmap -ErrorAction SilentlyContinue)) {
        Log "AVISO: Nmap não encontrado. Considere instalar para testes mais completos."
    }
    
    # Verificar se o Putty/Plink está instalado para SSH
    if (-not (Get-Command plink -ErrorAction SilentlyContinue)) {
        Log "AVISO: Plink (Putty) não encontrado. Testes SSH limitados."
    }
}

# Teste de conexão SSH
function Test-SSH {
    param (
        [string]$host
    )
    Log "Iniciando teste SSH em $host"
    
    # Tentativa de conexão básica (requer Plink/Putty)
    if (Get-Command plink -ErrorAction SilentlyContinue) {
        try {
            $output = plink -ssh "$SSH_USER@$host" -pw "wrongpassword" -batch -no-antispoof exit 2>&1
            Log $output
        } catch {
            Log "Erro SSH: $_"
        }
    } else {
        # Alternativa usando .NET (mais limitada)
        try {
            $sshClient = New-Object System.Net.Sockets.TcpClient($host, 22)
            Log "Conexão TCP/22 estabelecida com $host"
            $sshClient.Close()
        } catch {
            Log "Falha ao conectar em SSH ($host): $_"
        }
    }
    
    Log "Teste SSH concluído para $host"
}

# Teste de conexão MySQL
function Test-MySQL {
    param (
        [string]$host
    )
    Log "Iniciando teste MySQL em $host"
    
    # Requer MySQL Client instalado ou módulo MySql.Data
    try {
        # Tentativa básica de conexão (se o módulo MySQL estiver disponível)
        if (Get-Module -Name MySql.Data -ListAvailable) {
            Add-Type -Path "C:\Program Files (x86)\MySQL\MySQL Connector Net 8.0.XX\Assemblies\v4.5.2\MySql.Data.dll"
            $connStr = "server=$host;uid=$MYSQL_USER;pwd=wrongpassword;database=mysql;Connect Timeout=5"
            $conn = New-Object MySql.Data.MySqlClient.MySqlConnection($connStr)
            $conn.Open()
            Log "Conexão MySQL bem-sucedida (não esperado)"
            $conn.Close()
        } else {
            # Alternativa usando telnet/netcat para testar a porta
            Test-NetConnection -ComputerName $host -Port 3306 -InformationLevel Quiet
            if ($?) {
                Log "Porta MySQL (3306) aberta em $host"
            } else {
                Log "Falha ao conectar na porta MySQL (3306)"
            }
        }
    } catch {
        Log "Erro MySQL: $_"
    }
    
    Log "Teste MySQL concluído para $host"
}

# Teste de conexão RDP
function Test-RDP {
    param (
        [string]$host
    )
    Log "Iniciando teste RDP em $host"
    
    # Testar se a porta RDP está aberta
    try {
        $rdpTest = Test-NetConnection -ComputerName $host -Port 3389 -InformationLevel Detailed
        if ($rdpTest.TcpTestSucceeded) {
            Log "Porta RDP (3389) aberta em $host"
            
            # Tentativa de conexão RDP (simulada)
            Log "Simulando tentativa RDP com credenciais inválidas"
            # Nota: Não podemos realmente autenticar programaticamente sem ferramentas adicionais
        } else {
            Log "Porta RDP (3389) fechada em $host"
        }
    } catch {
        Log "Erro ao testar RDP: $_"
    }
    
    Log "Teste RDP concluído para $host"
}

# Teste de port scanning
function Test-PortScan {
    param (
        [string]$host
    )
    Log "Iniciando scan de portas em $host"
    
    # Portas comuns para testar
    $commonPorts = @(21, 22, 23, 80, 443, 3306, 3389, 8080)
    
    foreach ($port in $commonPorts) {
        try {
            $test = Test-NetConnection -ComputerName $host -Port $port -InformationLevel Quiet
            if ($test) {
                Log "Porta $port aberta em $host"
            } else {
                Log "Porta $port fechada em $host"
            }
        } catch {
            Log "Erro ao testar porta $port: $_"
        }
    }
    
    Log "Scan de portas concluído para $host"
}

# Teste de conexões genéricas
function Test-Generic {
    param (
        [string]$host
    )
    Log "Iniciando testes genéricos em $host"
    
    # Teste HTTP/HTTPS básico
    try {
        Log "Testando HTTP em $host"
        $httpResult = Invoke-WebRequest -Uri "http://$host" -TimeoutSec 5 -ErrorAction Stop
        Log "HTTP Response: $($httpResult.StatusCode)"
    } catch {
        Log "HTTP Error: $_"
    }
    
    try {
        Log "Testando HTTPS em $host"
        $httpsResult = Invoke-WebRequest -Uri "https://$host" -TimeoutSec 5 -ErrorAction Stop
        Log "HTTPS Response: $($httpsResult.StatusCode)"
    } catch {
        Log "HTTPS Error: $_"
    }
    
    Log "Testes genéricos concluídos para $host"
}

# Execução principal
function Main {
    Check-Dependencies
    Log "Iniciando testes de honeypot"
    
    foreach ($honeypot in $HONEYPOTS) {
        Log "Testando honeypot: $honeypot"
        Test-SSH -host $honeypot
        Test-MySQL -host $honeypot
        Test-RDP -host $honeypot
        Test-PortScan -host $honeypot
        Test-Generic -host $honeypot
        Log "Testes concluídos para $honeypot"
        Start-Sleep -Seconds 5
    }
    
    Log "Todos os testes foram concluídos"
    Log "Verifique os logs no Splunk para confirmar a coleta"
    Log "Log local salvo em: $LOG_FILE"
}

# Executar o script principal
Main
    log "Verifique os logs no Splunk para confirmar a coleta"
    log "Log local salvo em: $LOG_FILE"
}

main
