import streamlit as st
import pandas as pd
import plotly.express as px
from io import BytesIO

# Função para carregar e validar os dados
@st.cache_data
def load_and_validate_data(file):
    try:
        # Carregar o arquivo Excel
        df = pd.read_excel(file)
        
        # Verificar se as colunas necessárias estão presentes
        required_columns = ['Projetos', 'Departament', 'Fortifyonboardedstatus', 
                            'Critical', 'High', 'Medium', 'Low']
        for col in required_columns:
            if col not in df.columns:
                st.error(f"Coluna obrigatória ausente no arquivo: {col}")
                return None

        # Calcular total de vulnerabilidades
        df['Total Vulnerabilidades'] = df['Critical'] + df['High'] + df['Medium'] + df['Low']
        
        # Extrair nome base do projeto
        df['Projeto Base'] = df['Projetos'].apply(lambda x: x.split('-')[0])
        return df
    except Exception as e:
        st.error(f"Erro ao processar o arquivo: {e}")
        return None

# Função para criar gráficos e dashboards
def create_dashboards(df):
    # Título principal
    st.title("Dashboard de Vulnerabilidades de Projetos")
    
    # Filtro interativo por departamento
    st.sidebar.subheader("Filtros")
    selected_department = st.sidebar.selectbox("Selecione um Departamento", 
                                                options=["Todos"] + df['Departament'].unique().tolist())
    if selected_department != "Todos":
        df = df[df['Departament'] == selected_department]
    
    # Gráfico: Total de vulnerabilidades por projeto
    st.header("Total de Vulnerabilidades por Projeto")
    proj_vuln = df.groupby('Projetos')['Total Vulnerabilidades'].sum().reset_index()
    fig_proj_vuln = px.bar(proj_vuln, x='Projetos', y='Total Vulnerabilidades', 
                           title="Vulnerabilidades por Projeto", text='Total Vulnerabilidades')
    fig_proj_vuln.update_traces(textposition='outside')
    st.plotly_chart(fig_proj_vuln)

    # Gráfico: Status de deploy
    st.header("Status de Deploy dos Projetos")
    deploy_status = df['Fortifyonboardedstatus'].value_counts().reset_index()
    deploy_status.columns = ['Status', 'Quantidade']
    fig_deploy = px.pie(deploy_status, names='Status', values='Quantidade', title="Status de Deploy")
    st.plotly_chart(fig_deploy)

    # Gráfico: Vulnerabilidades por departamento
    st.header("Vulnerabilidades por Departamento")
    dept_vuln = df.groupby('Departament')[['Critical', 'High', 'Medium', 'Low']].sum().reset_index()
    fig_dept_vuln = px.bar(dept_vuln, x='Departament', y=['Critical', 'High', 'Medium', 'Low'],
                           title="Vulnerabilidades por Departamento", barmode='stack')
    st.plotly_chart(fig_dept_vuln)

    # Tabela: Projetos não deployados
    st.header("Projetos Não Deployados")
    not_deployed = df[df['Fortifyonboardedstatus'] != 'deployed']
    st.write(not_deployed)

# Função para gerar relatório Excel
def generate_excel(df):
    output = BytesIO()
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        df.to_excel(writer, index=False, sheet_name="Vulnerabilidades")
    processed_data = output.getvalue()
    return processed_data

# App Principal
def main():
    # Configurações do sidebar
    st.sidebar.title("Upload de Arquivo")
    uploaded_file = st.sidebar.file_uploader("Carregue um arquivo Excel", type=["xlsx"])

    # Carregar e processar os dados
    if uploaded_file:
        data = load_and_validate_data(uploaded_file)

        if data is not None:
            # Criar os dashboards
            create_dashboards(data)

            # Botão para download do relatório
            st.sidebar.subheader("Download do Relatório")
            excel_data = generate_excel(data)
            st.sidebar.download_button(label="Baixar Relatório Excel",
                                        data=excel_data,
                                        file_name="relatorio_vulnerabilidades.xlsx")
    else:
        st.write("Por favor, carregue um arquivo Excel para visualizar os dashboards.")

# Executar o app
if __name__ == "__main__":
    main()
